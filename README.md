# buffer
Note: specifics in regards to size can be found within comments in the textfiles!
### Level 1

In order to solve this level, I had to utilize what I knew about the stack. To begin with, I used the ‘objdump’ command in gdb in order to be able to view the assembly language. Then, I searched for the getbuf() function in the assembly code, and took a look at it in order to get a general idea of how the stack worked. I then found a line in the program—  “sub    $0x60,%rsp” — which essentially corresponds to the size of the buffer being set. This corresponds to 96 bytes being subtracted from rsp to make room for local variables on the stack. For this reason, in order to overflow this space in the stack so that the function getbuf() returns to lights_off() instead of to test_exploit(), the stack has to be filled with junk values up to the return address, so that it gets overwritten with the address of lights_off(). However, the size 96 must also include the return address- which, I discovered, was 8 bytes large. So, I therefore included 88 bytes of junk values for buf, as well as the return address in little endian, in the textfile. This was then converted from hex to raw, and worked when I ran it.

### Level 2

For this level, I followed a similar approach. I knew that, for the stack, the lower end of buffer consists of memory for the sandwhich_order() function, followed by a section for the old rbp value, and another section of memory sectioned off for the function arguments. Therefore, I looked at the function and saw that the buffer also needed 88 bytes of junk, followed by the return address pointing to to sandwhich_order, 8 bytes of junk, and the cookie generated by my computer as the first argument— since the sandwhich_order takes in a struct, ‘order’, as its first argument. Hence, the cookie would replace the first argument as the order ID. For the second argument, I entered a series of four arbitrary values, since in the order.sammiches array, there are four spaces for values. This, too, worked!

### Level 3

For this level, there were four primary things the code needed to do. First, I would have to write machine code that would have to put the cookie in %rax, store the value of rbp (since it gets corrupted), push the return location onto the stack, and then actually return the cookie. Here, it is guaranteed that the stack does not move. For that reason, the value of rbp does not change. Hence, I stepped through the test_exploit function in gdb in order to find what address was being stored in rbp. After finding this address, I knew that I would have to place it at the end of my textfile, since it would get executed last. In terms of the machine code, I moved the value of my cookie into rax, pushed the address of the location right after the line where the function ‘getbuf’ is called, and returned. I then had to find the location start of the buffer to put at the end of the textfile— which, in order to do so, I stepped through the text_exploit function in gdb and found the value of rdi.

As mentioned previously, a big part of this level involved restoring the corrupted state of the stack, caused by it being filled in a manner such that the return address (rbp) becomes badly damaged (since it gets overwritten). This is an issue, because the old rbp value for the caller function lets the program know how to go back to the stack and return to higher levels, as well as keep track of where it is at on the stack / stack frame. So, in order to make sure the value is not changed, I found the address of rbp, and put it after the 67 bytes of junk values in my textfile (since, in the stack, the segment following the junk values with pertains to rbp).  

### Level 4

Finally, for this level of the program, I knew it operated very similarly to level three, except that this time, the stack moved around, which was something I had to account for. Moreover, for this level, I also had to make use of the nop instruction. Essentially, at the start of the textfile I created, I knew that I had to fill it with various nops (represented by 0x90) before the exploit code, so that the program can slide along until the exploit code is reached. 

To start, I first wrote the machine code for this level. Since the stack moved around and the address of rbp wasn’t set, I accounted for the stack becoming corrupted by writing ‘lea 0x20(%rsp),%rbp’. What this line did was that it restored the stack by 8 bytes, undoing any of the corruption that was made. Then, I stored my cookie in the rax register (the return value), and pushed the return address to the line after the call to getbufn was made, so that the rest of the function could execute. 

Then, I started working on the fraudster textfile. After looking at the test_exploitn function, I saw that the size of the buffer was set to be 544 bytes. So, I knew that I needed a very large nop-sled so that the program would slide to where I needed it to. However, since the machine code (converted to hexadecimal) was 18 bytes, and each ‘line’ of the machine code was not evenly sized, I found the remainder when 18 was divided by 8 (2), and subtracted that from 8. So, 8-2 = 6 bytes of junk/padding were added in between the machine code, and the return address telling the program to go to the nop sled. Moreover, the 6 bytes of padding were needed since the buffer was allocated 544 bytes, and, including the 8 bytes accounting for the old value of rbp and the 8 bytes for the return address, would have to be 560 bytes in total. Therefore, the 6 bytes of padding were needed to ensure this.

To determine what the return address was, I ran the program in gdb and looked at the getbufn function five times, since the value of rbp was changed five times as the program was run for each of the 5 iterations of the string. Once I found five different addresses, I chose the largest one (the maximum address I could use) and converted it to little endian. This was to ensure that the return address was in the range. The reason the return address had to be put at the bottom of the text file was because I needed the hex values to be executed upward (thanks to the nop-sled). Hence, this is so that the nop sled is executed first, and then the program moves up the buffer up to the machine code.
